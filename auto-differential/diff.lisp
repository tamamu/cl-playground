(defun variablep (x) (symbolp x))
(defun same-valuep (v1 v2) (and (variablep v1) (variablep v2) (eq v1 v2)))
(defun =numberp (e n)
  (and (numberp e) (= e n)))
(defun make-sum (a1 a2)
  (cond ((=numberp a1 0) a2)
        ((=numberp a2 0) a1)
        ((and (numberp a1) (numberp a2)) (+ a1 a2))
        (t (list '+ a1 a2))))
(defun make-product (m1 m2)
  (cond ((or (=numberp m1 0) (=numberp m2 0)) 0)
        ((=numberp m1 1) m2)
        ((=numberp m2 1) m1)
        ((and (numberp m1) (numberp m2)) (* m1 m2))
        (t (list '* m1 m2))))
(defun sump (x) (and (consp x) (eq (car x) '+)))
(defun addend (s) (cadr s))
(defun augend (s) (caddr s))
(defun productp (x) (and (consp x) (eq (car x) '*)))
(defun multiplier (p) (cadr p))
(defun multiplicand (p) (caddr p))
(defun exponentiationp (e) (and (consp e) (eq (car e) '**)))
(defun base (e) (cadr e))
(defun exponent (e) (caddr e))
(defun make-exponentiation (e1 e2)
  (cond ((or (=numberp e1 0) (=numberp e1 1)) e1)
        ((=numberp e2 0) 1)
        ((=numberp e2 1) e1)
        ((and (numberp e1) (numberp e2)) (expt e1 e2))
        (t (list '** e1 e2))))
(defun subp (x) (and (consp x) (eq (car x) 'sub)))
(defun make-sub (e &rest rest)
  (append (list 'sub e) rest))
(defun sigmap (x)
  (and (consp x) (eq (car x) 'sigma)))
(defun make-sigma (index from to e)
  (list 'sigma index from to e))
(defun deriv (e v)
  (cond ((numberp e) 0)
        ((variablep e)
         (if (same-valuep e v) 1 0))
        ((sump e)
         (make-sum (deriv (addend e) v)
                   (deriv (augend e) v)))
        ((productp e)
         (make-sum
           (make-product (multiplier e)
                         (deriv (multiplicand e) v))
           (make-product (deriv (multiplier e) v)
                         (multiplicand e))))
        ((exponentiationp e)
         (make-product
           (make-product (exponent e)
                         (make-exponentiation (base e)
                                              (make-sum (exponent e) -1)))
           (deriv (base e) v)))
        ((subp e)
         (if (equal e v) 1 0))
        ((sigmap e)
         (destructuring-bind (index from to expression) (rest e)
           (loop for i :from from :to to
                 for a = (subst i index expression)
                 for d = (deriv a v)
                 if (or (variablep d) (and (numberp d) (not (zerop d))))
                 return d
                 finally (return e))))
        (t (error "unknown expression type"))))

